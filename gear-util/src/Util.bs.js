// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Unit$GearUtil = require("./Unit.bs.js");

function isEvenFloat(x) {
  return +(x % 2.0 === 0.0);
}

var partial_arg = Unit$GearUtil.Distance[/* convert */7];

function metreToKm(param) {
  return partial_arg(/* Metre */3, /* Km */4, param);
}

var partial_arg$1 = Unit$GearUtil.Distance[/* convert */7];

function metreToMile(param) {
  return partial_arg$1(/* Metre */3, /* Mile */5, param);
}

var partial_arg$2 = Unit$GearUtil.Distance[/* convert */7];

function inchToMetre(param) {
  return partial_arg$2(/* Inch */2, /* Metre */3, param);
}

var partial_arg$3 = Unit$GearUtil.Distance[/* convert */7];

function mmToInch(param) {
  return partial_arg$3(/* Mm */0, /* Inch */2, param);
}

var partial_arg$4 = Unit$GearUtil.Time[/* convert */8];

function minuteToHour(param) {
  return partial_arg$4(/* Minute */4, /* Hour */3, param);
}

function distancePerMinute(cadence, development) {
  return cadence * development;
}

function distancePerHour(cadence, development) {
  return minuteToHour(cadence * development);
}

function cadenceToSpeedKm(cadence, metresOfDevelopment) {
  var development = metreToKm(metresOfDevelopment);
  return minuteToHour(cadence * development);
}

function cadenceToSpeedMiles(cadence, metresOfDevelopment) {
  var development = metreToMile(metresOfDevelopment);
  return minuteToHour(cadence * development);
}

function equivalentGear(chainring, cog, range) {
  var baseRatio = /* float array */[
    chainring / cog,
    1.0
  ];
  return Belt_Array.reduce(range, /* [] */0, (function (gears, i) {
                var newRatio = /* float array */[
                  baseRatio[/* numerator */0] * i,
                  baseRatio[/* denominator */1] * i
                ];
                var match = isEvenFloat(newRatio[/* numerator */0]) && +(newRatio[/* numerator */0] < 60 && newRatio[/* denominator */1] > 10);
                if (match !== 0) {
                  return List.concat(/* :: */[
                              gears,
                              /* :: */[
                                /* :: */[
                                  newRatio,
                                  /* [] */0
                                ],
                                /* [] */0
                              ]
                            ]);
                } else {
                  return gears;
                }
              }));
}

function gearInches(wheelDiameter, chainring, cog) {
  return wheelDiameter * (chainring / cog);
}

function greatestCommonDivisor(_x, _y) {
  while(true) {
    var y = _y;
    var x = _x;
    var match = +(y > 0.0);
    if (match !== 0) {
      _y = x % y;
      _x = y;
      continue ;
      
    } else {
      return x;
    }
  };
}

function lowestFraction(numerator, denominator) {
  var gcd = greatestCommonDivisor(numerator, denominator);
  return /* float array */[
          numerator / gcd,
          denominator / gcd
        ];
}

function metresOfDevelopment(wheelDiameter, chainring, cog) {
  var gearMetre = inchToMetre(gearInches(wheelDiameter, chainring, cog));
  return gearMetre * Math.PI;
}

function skidPatches(chainring, cog) {
  return lowestFraction(chainring, cog)[/* denominator */1];
}

function ambidextrousSkidPatches(chainring, cog) {
  var patches = lowestFraction(chainring, cog)[/* denominator */1];
  var match = isEvenFloat(patches);
  if (match !== 0) {
    return patches;
  } else {
    return patches * 2.0;
  }
}

function radiusRatio(wheelDiameter, crank) {
  return wheelDiameter / 2.0 / mmToInch(crank);
}

function gainRatio(wheelDiameter, crank, chainring, cog) {
  var ratio = radiusRatio(wheelDiameter, crank);
  return ratio * chainring / cog;
}

exports.isEvenFloat = isEvenFloat;
exports.metreToKm = metreToKm;
exports.metreToMile = metreToMile;
exports.inchToMetre = inchToMetre;
exports.mmToInch = mmToInch;
exports.minuteToHour = minuteToHour;
exports.distancePerMinute = distancePerMinute;
exports.distancePerHour = distancePerHour;
exports.cadenceToSpeedKm = cadenceToSpeedKm;
exports.cadenceToSpeedMiles = cadenceToSpeedMiles;
exports.equivalentGear = equivalentGear;
exports.gearInches = gearInches;
exports.greatestCommonDivisor = greatestCommonDivisor;
exports.lowestFraction = lowestFraction;
exports.metresOfDevelopment = metresOfDevelopment;
exports.skidPatches = skidPatches;
exports.ambidextrousSkidPatches = ambidextrousSkidPatches;
exports.radiusRatio = radiusRatio;
exports.gainRatio = gainRatio;
/* No side effect */
